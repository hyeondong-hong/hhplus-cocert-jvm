## DB Lock

### 비관적 락 (배타락과 공유락)
* DB 엔진에서 제공하는 기능
* `SELECT … FROM A WHERE … FOR UPDATE` 로 A 테이블에 대해 배타락을 걸 수 있음
* `SELECT … FROM A WHERE … FOR SHARE` 로 A 테이블에 대해 공유락을 걸 수 있음
* 배타락은 읽기와 쓰기에 모두 락을 걸고, 공유락은 읽기는 허용하고 쓰기에만 락을 걺
* 여러 번 재사용 가능한 자원에 동시에 접근할 가능성이 있을 때 사용
    * 자원에 대한 순차적 접근에서도 대기하며 연속적으로 처리가 가능함
* 락이 걸려있는 상태에서 해당 레코드로 접근하면 JVM 스레드 풀과 DB 커넥션 풀을 쥔 상태로 대기하게 됨
* 데드락의 위험이 있음
    * 서로 다른 로직에서 같은 자원을 사용하면서 자원 접근 순서에 일관성이 없을 경우
    * 비결정성을 지닌 테이블에 order by를 걸지 않고 조회할 경우
        * ex. `4,3,2,1` 순서의 query와 `1,2,3,4` 순서의 query가 서로 동시에 락을 걸며 조회될 경우 서로 역순의 레코드를 각각 읽어 들일 때 순환 대기 상태에 빠짐

### 낙관적 락
* 논리적으로 구현해야 하는 기능
* `UPDATE A SET …, version=v+1 WHERE … AND version=v` 조건으로 A 테이블을 업데이트 시 영향을 받은 레코드가 0일 때 예외를 발생하는 방식으로 구현
* Spring에서는 엔티티에 `version` 필드를 정의하고 해당 필드에 `@Version` 어노테이션 설정을 통해 JPA가 제공하는 낙관적 락을 구현할 수 있음
* 하나 뿐인 자원에 동시에 접근할 가능성이 있을 때 사용
    * 동시 접근 시 늦게 업데이트를 시도한 트랜잭션에 대해 낙관적 락 예외를 발생하는 방식으로 구현
* 데드락이 일어나지 않음
    * 피지컬한 락을 걸지 않기 때문
* 락이 전혀 걸리지 않는 건 아니다? -> `MyISAM` 등 MVCC를 지원하지 않는 엔진에서 발생
    1. 트랜잭션1에서 버전이 1인 레코드를 수정함
    2. 동시에 트랜잭션2에서 버전이 1인 레코드를 수정함
    3. 트랜잭션1이 먼저 레코드를 버전2로 수정하고, 영향 받은 레코드 수가 1인 걸 확인하고 정상 처리를 반환하며 트랜잭션을 종료한다
    4. 트랜잭션2에서 레코드를 버전2로 수정하지만, 트랜잭션1이 롤백되는지 정상 커밋되는지 알 수 없기 때문에 트랜잭션1이 종료될 때 까지 대기함
    5. 트랜잭션2는 트랜잭션1이 종료된 후 영향 받은 레코드 수가 0인 걸 확인하고 낙관적 락 예외를 반환하며 트랜잭션을 종료한다
* 비관적 락과 마찬가지로 JVM 스레드 풀과 DB 커넥션 풀을 점유하지만 낙관적 락 예외 발생 시 즉시 점유를 풀고 커넥션을 해제할 수 있음
* 클라이언트에 의한 재시도 요청이 많을 경우 트랜잭션이 자주 여닫히게 되는 현상에 주의해야 함 (어쨌든 업데이트 시도 자체는 하기 때문에)


## Redis: 분산 락

### Redisson
* Java에서 Redis를 유용하게 사용할 수 있게 서포트하는 라이브러리
    * Redis가 존재하는 환경에서 단순 자바 코드로 직접 구현도 가능하지만...
    * 코드 복잡성을 줄일 뿐만 아니라 장애에 대한 후처리, 클러스터 환경에서의 안정성을 보장함
* `분산 락`, `세마포어`, `블로킹 큐`와 같은 고급 기능 제공 (여기서는 `분산 락` 기능만 설명)
* 분산 락을 거는 원리
    * Redis에 `SET {key} {value} NX PX {exp_millis}` 명령어 형태로 락을 생성
        * `key`: 락이 걸려야 하는 자원에 공통으로 사용되는 값을 입력
        * `value`: 락을 사용하는 식별자를 입력
        * `exp_millis`: 밀리초 단위로 자동으로 락을 해제하는 시간을 입력
    * 예를 들어, `SET scope1 thread22 NX PX 3000` 명령어로 `scope1`에 값 `thread22`를 입력한다고 가정
        * 키가 존재하지 않으면 `OK`를 반환하며 `scope1`에 `thread22` 값이 입력됨
        * 키가 존재하면 `null`을 반환하며 쓰기 작업을 진행하지 않음
    * 위 매커니즘을 통해 `OK`가 반환되면 트랜잭션을 열고, `null`이 반환되면 곧바로 예외를 반환할 수 있음
    * 비즈니스 로직이 완료되면 `DEL scope1` 명령어로 키를 삭제함으로써 락 해제 상태를 선언할 수 있음
        * `scope1`을 삭제할 때, `thread22` 자신이 잠갔는지 여부를 확인하기 위해 키를 삭제하기 전에 값을 비교하는 방법으로 안정성을 올릴 수 있음
        * 다음 명령어로 값 비교 가능
            * `EVAL "if redis.call('GET', KEYS[1]) == ARGV[1] then return redis.call('DEL', KEYS[1]) else return 0 end" 1 scope1 thread22`
            * `EVAL` 다음에 오는 문자열은 Lua 스크립트 본문
            * 문자열 뒤로 이어지는 `1 scope1 thread22`는 각각 키의 배열 길이, 키 이름, 값에 대응됨
            * `KEYS[1]` = `scope1`
            * `ARGV[1]` = `thread22`
* 분산 락을 거는 순서: 분산 락 -> 트랜잭션 열기 -> 비즈니스 로직 -> 트랜잭션 종료 -> 분산 락 해제
    * Spring에서는 `@Transactional` 블록 안에서 분산 락을 걸어 트랜잭션을 먼저 열고 분산 락을 처리하는 실수에 주의
    * 락에 접근하기 전에 트랜잭션이 먼저 열리거나 트랜잭션이 종료되기 전에 락이 해제되는 경우가 문제가 됨
    * 서로 다른 스레드풀에서 트랜잭션의 생명주기가 서로 겹치는 구간이 존재하면 MVCC에 의해 생성된 스냅샷은 업데이트 상태가 반영되지 않은 채로 트랜잭션으로 제공될 수 있음
    * 예를 들어, origin이 `1`인 데이터를 트랜잭션1에서 `2`로 수정했음에도 트랜잭션이 종료되지 않은 상황에서 열린 트랜잭션2에서는 여전히 origin이 `1`로 조회되는 현상이 발생
* DB의 매커니즘을 활용한 락과는 다르게 DB 커넥션 풀에 도달하기 전에 반환이 가능하기 때문에 DB 부하가 덜함
* 클라이언트 재시도 요청이 많아도 트랜잭션이 꼭 필요한 블록에서만 열리기 때문에 비교적 안정적
* 락을 해제하지 못하더라도 `PX {exp_millis}` 설정으로 일정 시간이 지나면 저절로 락이 해제되기 때문에 데드락 위험도 적은 편


## 메시지 브로커

### 메시지 큐
* 메시지 전송 프로토콜 규격으로는 표준 메시지 프로토콜인 `AMQP`, `STOMP`, `MQTT` 등이 존재함
* 래빗엠큐 등에서 사용되는 `AMQP` 프로토콜로 예를 들면
    * `amqp://` 또는 `amqps://`(보안 연결) 스키마를 사용
    * `amqp://username:password@hostname:port/vhost` 형식으로 브로커에 접속
    * 모든 프로토콜은 프레임 전송을 통해 메시지브로커와 상호작용
    * 프레임의 경우 메소드 프레임, 헤더 프레임, 본문 프레임에 나눠서 데이터 전송
    * 예를 들어, "Hello" 라는 데이터를 `Basic.Publish` 프레임으로 전송할 경우
        * 메소드 프레임
            * 타입: 0x01 (메소드 프레임)
            * 채널: 0x0001
            * 길이: 0x0000001A (예시)
            * 속성: 클래스ID, 메소드ID, Exchange명, 라우팅키, 플래그 포함
        * 헤더 프레임
            * 타입: 0x02 (헤더 프레임)
            * 채널: 0x0001
            * 길이: 0x0000000C (예시)
            * 속성: 클래스ID, 속성 플래그, Delivery모드, 본문 크기 포함
        * 본문 프레임
            * 타입: 0x03 (본문 프레임)
            * 채널: 0x0001
            * 길이: 0x00000005
            * 본문: 0x48656C6C6F(`Hello`)
        * 각각의 프레임을 프레임 엔드 코드(0xCE)와 함께 차례대로 전송
            * `01 0001 0000001A 003C000A... CE`
            * `02 0001 0000000C 003C0002... CE`
            * `03 0001 00000005 48656C6C6F CE`
* Kafka에서의 처리 방법
    * Kafka 클라이언트는 브로커와의 연결 시 고유 포트와 TCP를 사용
    * `PLAINTEXT://` 또는 `SSL://`(보안 연결) 스키마를 사용하여 독자적인 프로토콜을 통해 브로커에 접속
    * 프레임 기반 바이너리 프로토콜로 상호작용
    * Kafka의 프레임은 요청 타입, 헤더, 바디로 구성되어 전송
    * 예를 들어, "Hello"라는 데이터를 `Produce` 요청을 통해 전송할 경우
        * 요청 헤더
            * API 키: 0x0000 (`Produce`)
            * API 버전: 0x0001
            * 코릴레이션 ID: 0x00000001
            * 클라이언트 ID: 0x1234567812345678
        * 요청 바디
            * 토픽: 0x0000000A
            * 파티션: 0x0000
            * 메시지셋
                * 압축 방식: `None`, `GZIP`, `LZ4` 등
                * 데이터: 0x48656C6C6F(`Hello`)
        * 전체 요청을 바이너리 형식으로 브로커에 전송
            * `0000 0001 0001 00000001 1234567812345678 0000000A 0000 ... 48656C6C6F`
* 메시지 브로커에서의 요청과 응답은 코릴레이션 ID를 통해 연결됨
    * 브로커는 응답할 때 클라이언트가 요청했던 코릴레이션 ID를 사용하여 클라이언트가 자신의 요청에 대한 응답을 가져갈 수 있도록 처리
* 프로토콜과 각각의 메시지 브로커가 지향하는 방향에 따른 특성 차이는 있어도 메시지 큐를 가진다는 점은 대체로 비슷함
* 메시지 큐로 동시성 처리를 하는 원리 (Kafka)
    * 요청이 들어오면 해당 작업이 처리되는 메시지 브로커의 토픽으로 작업에 필요한 데이터를 전달
    * 전달이 완료되면 클라이언트는 작업의 성공/실패 여부가 아닌 요청 완료 메시지를 받게 됨
    * 메시지 큐에 쌓인 작업을 서비스 내 별도의 반복 처리되는 스레드 또는 외부 애플리케이션에서 받아서 처리
    * 이후 요청자는 다양한 방법으로 완료 여부를 확인 가능
        * 간단히 완료 여부를 API로 풀링하거나
        * 요청 완료 시점에 Websocket으로 준비된 서비스에 연결해서 완료 여부를 실시간으로 수신하거나
        * 푸쉬(FCM 등)를 통해 모바일 알림 또는 브라우저 이벤트를 통해 완료 여부를 알 수 있음
* 아예 락을 걸지 않기 때문에, 락을 걸고 해제하는 과정에서 발생하는 네트워크 레이턴시로 인한 리소스 손실이 없음
